{"version":3,"file":"jsonrepair.js","names":["JSONRepairError","codeAsterisk","codeBackslash","codeCloseParenthesis","codeClosingBrace","codeClosingBracket","codeColon","codeComma","codeDot","codeDoubleQuote","codeLowercaseE","codeMinus","codeNewline","codeOpeningBrace","codeOpeningBracket","codeOpenParenthesis","codePlus","codeSemicolon","codeSlash","codeUppercaseE","codeZero","endsWithCommaOrNewline","insertBeforeLastWhitespace","isControlCharacter","isDelimiter","isDigit","isDoubleQuote","isHex","isNonZeroDigit","isQuote","isSingleQuote","isSpecialWhitespace","isStartOfValue","isValidStringCharacter","isWhitespace","removeAtIndex","stripLastOccurrence","controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepair","text","i","output","processed","parseValue","throwUnexpectedEnd","processedComma","parseCharacter","parseWhitespaceAndSkipComments","parseNewlineDelimitedJSON","length","throwUnexpectedCharacter","parseObject","parseArray","parseString","parseNumber","parseKeywords","parseUnquotedString","start","changed","parseWhitespace","parseComment","whitespace","normal","charCodeAt","atEndOfBlockComment","code","skipCharacter","skipEscapeCharacter","initial","processedKey","undefined","throwObjectKeyExpected","processedColon","throwColonExpected","processedValue","throwObjectValueExpected","skipEscapeChars","isEndQuote","char","escapeChar","slice","throwInvalidUnicodeCharacter","throwInvalidCharacter","parseConcatenatedString","expectDigit","parseKeyword","name","value","symbol","JSON","stringify","numSoFar","got","end","test","chars"],"sources":["../../src/jsonrepair.ts"],"sourcesContent":["import { JSONRepairError } from './JSONRepairError.js'\nimport {\n  codeAsterisk,\n  codeBackslash,\n  codeCloseParenthesis,\n  codeClosingBrace,\n  codeClosingBracket,\n  codeColon,\n  codeComma,\n  codeDot,\n  codeDoubleQuote,\n  codeLowercaseE,\n  codeMinus,\n  codeNewline,\n  codeOpeningBrace,\n  codeOpeningBracket,\n  codeOpenParenthesis,\n  codePlus,\n  codeSemicolon,\n  codeSlash,\n  codeUppercaseE,\n  codeZero,\n  endsWithCommaOrNewline,\n  insertBeforeLastWhitespace,\n  isControlCharacter,\n  isDelimiter,\n  isDigit,\n  isDoubleQuote,\n  isHex,\n  isNonZeroDigit,\n  isQuote,\n  isSingleQuote,\n  isSpecialWhitespace,\n  isStartOfValue,\n  isValidStringCharacter,\n  isWhitespace,\n  removeAtIndex,\n  stripLastOccurrence\n} from './stringUtils.js'\n\nconst controlCharacters: { [key: string]: string } = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\n// map with all escape characters\nconst escapeCharacters: { [key: string]: string } = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     try {\n *       const json = \"{name: 'John'}\"\n *       const repaired = jsonrepair(json)\n *       console.log(repaired)\n *       // '{\"name\": \"John\"}'\n *     } catch (err) {\n *       console.error(err)\n *     }\n *\n */\nexport function jsonrepair(text: string): string {\n  let i = 0 // current index in text\n  let output = '' // generated output\n\n  const processed = parseValue()\n  if (!processed) {\n    throwUnexpectedEnd()\n  }\n\n  const processedComma = parseCharacter(codeComma)\n  if (processedComma) {\n    parseWhitespaceAndSkipComments()\n  }\n\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n    if (!processedComma) {\n      // repair missing comma\n      output = insertBeforeLastWhitespace(output, ',')\n    }\n\n    parseNewlineDelimitedJSON()\n  } else if (processedComma) {\n    // repair: remove trailing comma\n    output = stripLastOccurrence(output, ',')\n  }\n\n  if (i >= text.length) {\n    // reached the end of the document properly\n    return output\n  }\n\n  throwUnexpectedCharacter()\n\n  function parseValue(): boolean {\n    parseWhitespaceAndSkipComments()\n    const processed =\n      parseObject() ||\n      parseArray() ||\n      parseString() ||\n      parseNumber() ||\n      parseKeywords() ||\n      parseUnquotedString()\n    parseWhitespaceAndSkipComments()\n\n    return processed\n  }\n\n  function parseWhitespaceAndSkipComments(): boolean {\n    const start = i\n\n    let changed = parseWhitespace()\n    do {\n      changed = parseComment()\n      if (changed) {\n        changed = parseWhitespace()\n      }\n    } while (changed)\n\n    return i > start\n  }\n\n  function parseWhitespace(): boolean {\n    let whitespace = ''\n    let normal: boolean\n    while ((normal = isWhitespace(text.charCodeAt(i))) || isSpecialWhitespace(text.charCodeAt(i))) {\n      if (normal) {\n        whitespace += text[i]\n      } else {\n        // repair special whitespace\n        whitespace += ' '\n      }\n\n      i++\n    }\n\n    if (whitespace.length > 0) {\n      output += whitespace\n      return true\n    }\n\n    return false\n  }\n\n  function parseComment(): boolean {\n    // find a block comment '/* ... */'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeAsterisk) {\n      // repair block comment by skipping it\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\n        i++\n      }\n      i += 2\n\n      return true\n    }\n\n    // find a line comment '// ...'\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeSlash) {\n      // repair line comment by skipping it\n      while (i < text.length && text.charCodeAt(i) !== codeNewline) {\n        i++\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  function parseCharacter(code: number): boolean {\n    if (text.charCodeAt(i) === code) {\n      output += text[i]\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipCharacter(code: number): boolean {\n    if (text.charCodeAt(i) === code) {\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipEscapeCharacter(): boolean {\n    return skipCharacter(codeBackslash)\n  }\n\n  /**\n   * Parse an object like '{\"key\": \"value\"}'\n   */\n  function parseObject(): boolean {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      output += '{'\n      i++\n      parseWhitespaceAndSkipComments()\n\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        let processedComma\n        if (!initial) {\n          processedComma = parseCharacter(codeComma)\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n          parseWhitespaceAndSkipComments()\n        } else {\n          processedComma = true\n          initial = false\n        }\n\n        const processedKey = parseString() || parseUnquotedString()\n        if (!processedKey) {\n          if (\n            text.charCodeAt(i) === codeClosingBrace ||\n            text.charCodeAt(i) === codeOpeningBrace ||\n            text.charCodeAt(i) === codeClosingBracket ||\n            text.charCodeAt(i) === codeOpeningBracket ||\n            text[i] === undefined\n          ) {\n            // repair trailing comma\n            output = stripLastOccurrence(output, ',')\n          } else {\n            throwObjectKeyExpected()\n          }\n          break\n        }\n\n        parseWhitespaceAndSkipComments()\n        const processedColon = parseCharacter(codeColon)\n        if (!processedColon) {\n          if (isStartOfValue(text[i])) {\n            // repair missing colon\n            output = insertBeforeLastWhitespace(output, ':')\n          } else {\n            throwColonExpected()\n          }\n        }\n        const processedValue = parseValue()\n        if (!processedValue) {\n          if (processedColon) {\n            throwObjectValueExpected()\n          } else {\n            throwColonExpected()\n          }\n        }\n      }\n\n      if (text.charCodeAt(i) === codeClosingBrace) {\n        output += '}'\n        i++\n      } else {\n        // repair missing end bracket\n        output = insertBeforeLastWhitespace(output, '}')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse an array like '[\"item1\", \"item2\", ...]'\n   */\n  function parseArray(): boolean {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      output += '['\n      i++\n      parseWhitespaceAndSkipComments()\n\n      let initial = true\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          const processedComma = parseCharacter(codeComma)\n          if (!processedComma) {\n            // repair missing comma\n            output = insertBeforeLastWhitespace(output, ',')\n          }\n        } else {\n          initial = false\n        }\n\n        const processedValue = parseValue()\n        if (!processedValue) {\n          // repair trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      }\n\n      if (text.charCodeAt(i) === codeClosingBracket) {\n        output += ']'\n        i++\n      } else {\n        // repair missing closing array bracket\n        output = insertBeforeLastWhitespace(output, ']')\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse and repair Newline Delimited JSON (NDJSON):\n   * multiple JSON objects separated by a newline character\n   */\n  function parseNewlineDelimitedJSON() {\n    // repair NDJSON\n    let initial = true\n    let processedValue = true\n    while (processedValue) {\n      if (!initial) {\n        // parse optional comma, insert when missing\n        const processedComma = parseCharacter(codeComma)\n        if (!processedComma) {\n          // repair: add missing comma\n          output = insertBeforeLastWhitespace(output, ',')\n        }\n      } else {\n        initial = false\n      }\n\n      processedValue = parseValue()\n    }\n\n    if (!processedValue) {\n      // repair: remove trailing comma\n      output = stripLastOccurrence(output, ',')\n    }\n\n    // repair: wrap the output inside array brackets\n    output = `[\\n${output}\\n]`\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   */\n  function parseString(): boolean {\n    let skipEscapeChars = text.charCodeAt(i) === codeBackslash\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++\n      skipEscapeChars = true\n    }\n\n    if (isQuote(text.charCodeAt(i))) {\n      const isEndQuote = isSingleQuote(text.charCodeAt(i)) ? isSingleQuote : isDoubleQuote\n\n      if (text.charCodeAt(i) !== codeDoubleQuote) {\n        // repair non-normalized quote\n      }\n      output += '\"'\n      i++\n\n      while (i < text.length && !isEndQuote(text.charCodeAt(i))) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1]\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            output += text.slice(i, i + 2)\n            i += 2\n          } else if (char === 'u') {\n            if (\n              isHex(text.charCodeAt(i + 2)) &&\n              isHex(text.charCodeAt(i + 3)) &&\n              isHex(text.charCodeAt(i + 4)) &&\n              isHex(text.charCodeAt(i + 5))\n            ) {\n              output += text.slice(i, i + 6)\n              i += 6\n            } else {\n              throwInvalidUnicodeCharacter(i)\n            }\n          } else {\n            // repair invalid escape character: remove it\n            output += char\n            i += 2\n          }\n        } else {\n          const char = text[i]\n          const code = text.charCodeAt(i)\n\n          if (code === codeDoubleQuote && text.charCodeAt(i - 1) !== codeBackslash) {\n            // repair unescaped double quote\n            output += '\\\\' + char\n            i++\n          } else if (isControlCharacter(code)) {\n            // unescaped control character\n            output += controlCharacters[char]\n            i++\n          } else {\n            if (!isValidStringCharacter(code)) {\n              throwInvalidCharacter(char)\n            }\n            output += char\n            i++\n          }\n        }\n\n        if (skipEscapeChars) {\n          const processed = skipEscapeCharacter()\n          if (processed) {\n            // repair: skipped escape character (nothing to do)\n          }\n        }\n      }\n\n      if (isQuote(text.charCodeAt(i))) {\n        if (text.charCodeAt(i) !== codeDoubleQuote) {\n          // repair non-normalized quote\n        }\n        output += '\"'\n        i++\n      } else {\n        // repair missing end quote\n        output += '\"'\n      }\n\n      parseConcatenatedString()\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString(): boolean {\n    let processed = false\n\n    parseWhitespaceAndSkipComments()\n    while (text.charCodeAt(i) === codePlus) {\n      processed = true\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: remove the end quote of the first string\n      output = stripLastOccurrence(output, '\"', true)\n      const start = output.length\n      parseString()\n\n      // repair: remove the start quote of the second string\n      output = removeAtIndex(output, start, 1)\n    }\n\n    return processed\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber(): boolean {\n    const start = i\n    if (text.charCodeAt(i) === codeMinus) {\n      i++\n      expectDigit(start)\n    }\n\n    if (text.charCodeAt(i) === codeZero) {\n      i++\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeDot) {\n      i++\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++\n      }\n      expectDigit(start)\n      while (isDigit(text.charCodeAt(i))) {\n        i++\n      }\n    }\n\n    if (i > start) {\n      output += text.slice(start, i)\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords(): boolean {\n    return (\n      parseKeyword('true', 'true') ||\n      parseKeyword('false', 'false') ||\n      parseKeyword('null', 'null') ||\n      // repair Python keywords True, False, None\n      parseKeyword('True', 'true') ||\n      parseKeyword('False', 'false') ||\n      parseKeyword('None', 'null')\n    )\n  }\n\n  function parseKeyword(name: string, value: string): boolean {\n    if (text.slice(i, i + name.length) === name) {\n      output += value\n      i += name.length\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Repair and unquoted string by adding quotes around it\n   * Repair a MongoDB function call like NumberLong(\"2\")\n   * Repair a JSONP function call like callback({...});\n   */\n  function parseUnquotedString() {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    const start = i\n    while (i < text.length && !isDelimiter(text[i])) {\n      i++\n    }\n\n    if (i > start) {\n      if (text.charCodeAt(i) === codeOpenParenthesis) {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        i++\n\n        parseValue()\n\n        if (text.charCodeAt(i) === codeCloseParenthesis) {\n          // repair: skip close bracket of function call\n          i++\n          if (text.charCodeAt(i) === codeSemicolon) {\n            // repair: skip semicolon after JSONP call\n            i++\n          }\n        }\n\n        return true\n      } else {\n        // repair unquoted string\n\n        // first, go back to prevent getting trailing whitespaces in the string\n        while (isWhitespace(text.charCodeAt(i - 1)) && i > 0) {\n          i--\n        }\n\n        const symbol = text.slice(start, i)\n        output += JSON.stringify(symbol)\n\n        return true\n      }\n    }\n  }\n\n  function expectDigit(start: number) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i)\n      throw new JSONRepairError(`Invalid number '${numSoFar}', expecting a digit ${got()}`, 2)\n    }\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new JSONRepairError('Invalid character ' + JSON.stringify(char), i)\n  }\n\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError('Unexpected character ' + JSON.stringify(text[i]), i)\n  }\n\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', text.length)\n  }\n\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i)\n  }\n\n  function throwObjectValueExpected() {\n    throw new JSONRepairError('Object value expected', i)\n  }\n\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i)\n  }\n\n  function throwInvalidUnicodeCharacter(start: number) {\n    let end = start + 2\n    while (/\\w/.test(text[end])) {\n      end++\n    }\n    const chars = text.slice(start, end)\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\n  }\n\n  function got(): string {\n    return text[i] ? `but got '${text[i]}'` : 'but reached end of input'\n  }\n}\n\nfunction atEndOfBlockComment(text: string, i: number) {\n  return text[i] === '*' && text[i + 1] === '/'\n}\n"],"mappings":"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"}